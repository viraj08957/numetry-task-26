{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // TODO: Implement using only matrices to support skew and even more operations than css.\n\n\nvar getRotation = function getRotation(transform) {\n  var match = /rotate\\((-?\\d+(.\\d+)?)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[3]) {\n    var value = match[1];\n    return match[3] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nvar getTranslateX = function getTranslateX(transform) {\n  var matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nvar getTranslateY = function getTranslateY(transform) {\n  var matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nvar getScaleX = function getScaleX(transform) {\n  var matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nvar getScaleY = function getScaleY(transform) {\n  var matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nvar getMatrix = function getMatrix(transform) {\n  var match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin: origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin: origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin: origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform.apply(ctx, getMatrix(transform));\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var match;\n  var re = /[a-zA-Z]+\\([^)]+\\)/g;\n  var origin = [node.origin.left, node.origin.top];\n  var transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/Viraj/Desktop/task 26/resume-builder/node_modules/@react-pdf/render/lib/operations/transform.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","getRotation","transform","match","exec","value","Math","PI","getTranslateX","matchX","matchGeneric","getTranslateY","matchY","getScaleX","getScaleY","getMatrix","slice","applySingleTransformation","ctx","origin","test","rotate","scale","translate","apply","applyTransformations","node","re","left","top","style","props","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nvar getRotation = function getRotation(transform) {\n  var match = /rotate\\((-?\\d+(.\\d+)?)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[3]) {\n    var value = match[1];\n    return match[3] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nvar getTranslateX = function getTranslateX(transform) {\n  var matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nvar getTranslateY = function getTranslateY(transform) {\n  var matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nvar getScaleX = function getScaleX(transform) {\n  var matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nvar getScaleY = function getScaleY(transform) {\n  var matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nvar getMatrix = function getMatrix(transform) {\n  var match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin: origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin: origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin: origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform.apply(ctx, getMatrix(transform));\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var match;\n  var re = /[a-zA-Z]+\\([^)]+\\)/g;\n  var origin = [node.origin.left, node.origin.top];\n  var transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}